//    JFuncTest - Functional testig in Java
//    Copyright (C) 2010 G. Andrieu (subtenante gmail com)
//
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program.  If not, see <http://www.gnu.org/licenses/>.
package jfunky;

import java.io.File;
import java.io.PrintWriter;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.List;

import jfunky.annotations.After;
import jfunky.annotations.Before;
import jfunky.annotations.Ignore;
import jfunky.annotations.Test;
import jfunky.render.Renderer;


/**
 * 
 * Use or extend this class to launch a set of tests.
 * 
 * Extend to provide implementations of {@link #beforeSuite()}
 * and {@link #afterSuite()} methods.
 * 
 * Basical usage needs to call {@link #setRenderer(Renderer)}
 * with a {@link Renderer} instance
 * and tell where to write the report with {@link #setFolderOut(File)}.
 * 
 * Then call {@link #addTest(Class)} to add the tests to be run,
 * once by class to be tested.
 * 
 * @author G.Andrieu
 *
 */
public class BaseTestSuite {

	//+++++ ATTRIBUTES
	/** the renderer */
	private Renderer renderer;
	/** the tests to be executed */
	private final List<BaseTestCase> tests = new ArrayList<BaseTestCase>();
	/** the folder where to write the reports generated by the Renderer */
	private File folderOut = new File(""); 
	//----- ATTRIBUTES
	
	//+++++ PUBLIC
	/**
	 * Override this to provide code to be executed before everything
	 */
	public void beforeSuite(){}
	
	/**
	 * Call this to run the tests present in this instance's list of Classes to test
	 */
	public void runTests(){
		for (BaseTestCase testcase: tests){
			try{
				Class<?> clazz = testcase.getClass();
				
				// Before
				testcase.beforeAll();
				for (Method m : clazz.getMethods()){
					m.getDeclaredAnnotations();
					if (m.getAnnotation(Before.class) != null){
						invoke(testcase, m);
					}
				}
				
				// Run tests
				for (Method m : clazz.getMethods()){
					if ((m.getModifiers() & Modifier.PUBLIC) == 0) continue;
					if ((m.getModifiers() & Modifier.STATIC) > 0) continue;
					if (m.getName().equals("beforeAll")) continue;
					if (m.getAnnotation(Before.class) != null) continue;
					if (m.getAnnotation(After.class) != null) continue;
					if (m.getName().equals("afterAll")) continue;
					if (m.getAnnotation(Ignore.class) != null) continue;
					if (m.getAnnotation(Test.class) != null){
						invoke(testcase, m);	
					}
				}
				
				// After
				for (Method m : clazz.getMethods()){
					if (m.getAnnotation(After.class) != null){
						invoke(testcase, m);	
					}
				}
				testcase.afterAll();
				
				
				// Render
				File outFile = new File(this.folderOut,"TEST-"+clazz.getCanonicalName()+".xml");
				PrintWriter writer = new PrintWriter(outFile);
				synchronized (this.renderer) {
					this.renderer.setWriter(writer);
					this.renderer.render(testcase);
				}
				
			}
			catch(Exception e){
				e.printStackTrace();
			}
		}
	}
	
	/**
	 * Override this to provide code to be executed after everything
	 * (like cleaning up, etc.)
	 */
	public void afterSuite(){}
	//----- PUBLIC
	
	//+++++ ACCESSORS
	public Renderer getRenderer() {
		return renderer;
	}

	public void setRenderer(Renderer renderer) {
		this.renderer = renderer;
	}
	
	public void addTest(Class<? extends BaseTestCase> testClass) {
		try{
			this.tests.add(testClass.newInstance());
		}
		catch(Exception e){
			e.printStackTrace();
		}
	}

	public void setFolderOut(File folderOut) {
		this.folderOut = folderOut;
	}
	//----- ACCESSORS
	
	//+++++ PRIVATE
	/** invoke a method on an object, takes care of possible exceptions */
	private void invoke(BaseTestCase testcase, Method m){
		try{
			m.invoke(testcase, new Object[]{});
		}
		catch(Throwable t){
			testcase.function(m.getName()).fails(t);
		}
	}
	//----- PRIVATE
	
}
